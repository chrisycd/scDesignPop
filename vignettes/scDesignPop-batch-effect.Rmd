---
title: "Modeling batch effect in population-scale scRNA-seq data"
author: 
  - name: Chris Dong
    affiliation:
    - Department of Statistics and Data Science, University of California, Los Angeles
    email: cycd@g.ucla.edu
  - name: Yihui Cen
    affiliation:
    - Department of Computational Medicine, University of California, Los Angeles
    email: yihuicen@g.ucla.edu
output: 
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
package: "`r pkg_ver('scDesignPop')`"
vignette: >
  %\VignetteIndexEntry{scDesignPop-batch-effect}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---
```{css, echo=FALSE}
pre {
  white-space: pre !important;
  overflow-x: scroll !important;
}
```

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    message = FALSE,
    collapse = TRUE,
    comment = "#>",
    crop = NULL ## Related to https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016656.html
)
tools::R_user_dir("scDesignPop", which="cache")
```

```{r, message=FALSE, warning=FALSE, results='hide'}
library(scDesignPop)
library(SingleCellExperiment)
library(SummarizedExperiment)
library(ggplot2)
theme_set(theme_bw())
```

## Introduction
scDesignPop can model population-scale scRNA-seq data with batch covariates and enables simulation of datasets under user-specified batch effects, including scenarios in which batch effects are added or removed.

## Library and data preparation

Here, we use an example SingleCellExperiment object `example_sce` with 1000 genes and 7811 cells and an example eQTL genotype dataframe `example_eqtlgeno` to demonstrate the main tutorial. These two objects contains the gene expression and SNP genotypes of 40 anonymized individuals while the eQTL genotype dataframe provides 2826 putative cell-type-specific eQTLs.

```{r}
library(scDesignPop)
library(SingleCellExperiment)
library(SummarizedExperiment)
library(ggplot2)

data("example_sce")
data("example_eqtlgeno")
```

The `example_sce` object also includes a pseudo-batch covariate, where batch labels are randomly assigned to the 40 individuals at the individual level and applied to all cells belonging to each individual.
```{r}
colData(example_sce)
```

## Fitting batch effects

### Step 1: construct a data list

To run scDesignPop, a list of data is required as input. This is done using the `constructDataPop` function. A `SingleCellExperiment` object and an `eqtlgeno` dataframe are the two main inputs needed. The `eqtlgeno` dataframe consists of eQTL annotations (it must have cell state, gene, SNP, chromosome, and position columns at a minimum), and genotypes across individuals (columns) for every SNP (rows). The structure of an example `eqtlgeno` dataframe is given below.

```{r}
data_list <- constructDataPop(
    sce = example_sce,
    eqtlgeno_df = example_eqtlgeno,
    new_covariate = as.data.frame(colData(example_sce)),
    overlap_features = NULL,
    sampid_vec = NULL,
    copula_variable = "cell_type",
    slot_name = "counts",
    snp_mode = "single",
    celltype_colname = "cell_type",
    feature_colname = "gene_id",
    snp_colname = "snp_id",
    loc_colname = "POS",
    chrom_colname = "CHR",
    indiv_colname = "indiv",
    prune_thres = 0.9
    )
```

### Step 2: fit marginal model

Next, a marginal model is specified to fit each gene using the
`fitMarginalPop` function.  
Here we use a Negative Binominal as the parametric model using `"nb"`. Since we want to include the batch effect modeling, we specify `mean_formula = "(1|indiv) + cell_type + batch`. Here, we use pseudo-batches to show how scDesignPop can model and alter the batch effects.

```{r}
marginal_list <- fitMarginalPop(
    data_list = data_list,
    mean_formula = "(1|indiv) + cell_type + batch",
    model_family = "nb",
    interact_colnames = "cell_type",
    parallelization = "pbmcapply",
    n_threads = 20L,
    loc_colname = "POS",
    snp_colname = "snp_id",
    celltype_colname = "cell_type",
    indiv_colname = "indiv",
    filter_snps = TRUE,
    snpvar_thres = 0,
    force_formula = FALSE,
    data_maxsize = 1
    )
```

### Step 3: fit a Gaussian copula

The third step is to fit a Gaussian copula using the `fitCopulaPop`
function.

```{r}
set.seed(123, kind = "L'Ecuyer-CMRG")

copula_fit <- fitCopulaPop(
    sce = example_sce,
    assay_use = "counts",
    input_data = data_list[["new_covariate"]],
    marginal_list = marginal_list,
    family_use = "nb",
    copula = "gaussian",
    n_cores = 2L,
    parallelization = "mcmapply"
    )

RNGkind("Mersenne-Twister")  # reset
```

### Step 4: extract parameters

The fourth step is to compute the mean, sigma, and zero probability
parameters using the `extractParaPop` function.

```{r}
para_new <- extractParaPop(
    sce = example_sce,
    assay_use = "counts",
    marginal_list = marginal_list,
    n_cores = 2L,
    family_use = "nb",
    indiv_colname = "indiv",
    new_covariate = data_list[["new_covariate"]],
    new_eqtl_geno_list = data_list[["eqtl_geno_list"]],
    data = data_list[["covariate"]],
    parallelization = "pbmcmapply"
    )
```

### Step 5: simulate counts

The fifth step is to simulate counts using the `simuNewPop` function.

```{r}
set.seed(123)

newcount_mat <- simuNewPop(
    sce = example_sce,
    mean_mat = para_new[["mean_mat"]],
    sigma_mat = para_new[["sigma_mat"]],
    zero_mat = para_new[["zero_mat"]],
    quantile_mat = NULL,
    copula_list = copula_fit[["copula_list"]],
    n_cores = 2L,
    family_use = "nb",
    nonnegative = TRUE,
    input_data = data_list[["covariate"]],
    new_covariate = data_list[["new_covariate"]],
    important_feature = copula_fit[["important_feature"]],
    filtered_gene = data_list[["filtered_gene"]],
    parallelization = "pbmcmapply"
    )
```

### Step 6: create SingleCellExperiment object using simulated data

After simulating the data, we can create a `SingleCellExperiment` object
as follows.

```{r}
simu_sce <- SingleCellExperiment(list(counts = newcount_mat), 
                                 colData = data_list[["new_covariate"]])
names(assays(simu_sce)) <- "counts"

# save gene meta data
rowData(simu_sce) <- rowData(example_sce)
```

## Set new batch effects

### Step 1: set new batch effect sizes in marginal models

Check the rank of the batch effect sizes in the marginal distributions. Here, we take the gene `ENSG00000023902` as example since every gene are fitted using the same formula.
```{r}
marginal_list$ENSG00000023902$fit
```

After the ranks of the batch effects are obtained, set a new value to the gene marginal models and check the summary report again.
```{r}
marginal_list_diff <- lapply(marginal_list, function(x) {
  val <- rnorm(1, mean = 10, sd = 2) # set zero for batch effect removal
  x$fit$fit$par[5] <- val
  x$fit$fit$parfull[5] <- val
  x$fit$sdr$par.fixed[5] <- val
  x
})

marginal_list_diff$ENSG00000023902$fit
```

### Step 2: re-extract the parameters
```{r}
para_new_diff <- extractParaPop(
    sce = example_sce,
    assay_use = "counts",
    marginal_list = marginal_list_diff,
    n_cores = 2L,
    family_use = "nb",
    indiv_colname = "indiv",
    new_covariate = data_list[["new_covariate"]],
    new_eqtl_geno_list = data_list[["eqtl_geno_list"]],
    data = data_list[["covariate"]],
    parallelization = "pbmcmapply"
    )
```

### Step 3: simulate counts with batch effects
```{r}
set.seed(123)

newcount_mat_diff <- simuNewPop(
    sce = example_sce,
    mean_mat = para_new_diff[["mean_mat"]],
    sigma_mat = para_new_diff[["sigma_mat"]],
    zero_mat = para_new_diff[["zero_mat"]],
    quantile_mat = NULL,
    copula_list = copula_fit[["copula_list"]],
    n_cores = 2L,
    family_use = "nb",
    nonnegative = TRUE,
    input_data = data_list[["covariate"]],
    new_covariate = data_list[["new_covariate"]],
    important_feature = copula_fit[["important_feature"]],
    filtered_gene = data_list[["filtered_gene"]],
    parallelization = "pbmcmapply"
    )
```

### Step 4: create SingleCellExperiment object using simulated data

After simulating the data, we can create a `SingleCellExperiment` object
as follows.

```{r}
simu_sce_diff <- SingleCellExperiment(list(counts = newcount_mat_diff), 
                                 colData = data_list[["new_covariate"]])
names(assays(simu_sce_diff)) <- "counts"

# save gene meta data
rowData(simu_sce_diff) <- rowData(example_sce)
```

## Visualization

The simulated data can be visualized using a UMAP plot as follows.

```{r}
logcounts(simu_sce) <- log1p(counts(simu_sce))
logcounts(simu_sce_diff) <- log1p(counts(simu_sce_diff))
set.seed(123)
compare_figure <- scDesignPop::plotReducedDimPop(
    ref_sce = example_sce,
    sce_list = list(simu_sce, simu_sce_diff), 
    name_vec = c("Reference", "w/o batch effects", "w/ batch effects"),
    assay_use = "logcounts", 
    if_plot = TRUE, 
    color_by = "batch", point_size = 0.1,
    n_pc = 30)
plot(compare_figure$p_umap)
```

## Session information
```{r}
sessionInfo()
```
